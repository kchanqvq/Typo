(in-package #:typo.vm)

;;; Types

(deftype u8 () '(unsigned-byte 8))
(deftype u16 () '(unsigned-byte 16))
(deftype u32 () '(unsigned-byte 32))
(deftype u64 () '(unsigned-byte 64))

(deftype s8 () '(unsigned-byte 8))
(deftype s16 () '(unsigned-byte 16))
(deftype s32 () '(unsigned-byte 32))
(deftype s64 () '(unsigned-byte 64))

;;; Wrappers

(macrolet ((def (name bits)
             `(progn
                (declaim (inline ,name))
                (defun ,name (integer)
                  (declare (integer integer))
                  (mod integer ,(expt 2 bits))))))
  (def  u8-wrap  8)
  (def u16-wrap 16)
  (def u32-wrap 32)
  (def u64-wrap 64))

(macrolet ((def (name bits)
             (let ((offset (expt 2 (1- bits))))
               `(progn
                  (declaim (inline ,name))
                  (defun ,name (integer)
                        (declare (integer integer))
                        (- (mod (+ integer ,offset) ,(expt 2 bits))
                           ,offset))))))
  (def  s8-wrap  8)
  (def s16-wrap 16)
  (def s32-wrap 32)
  (def s64-wrap 64))

;;; Unary Operations
#|
(def u8 u8-not lognot u8-wrap)
(def u16 u16-not lognot u16-wrap)
(def u32 u32-not lognot u32-wrap)
(def u64 u64-not lognot u64-wrap)
(def s8 s8-not lognot s8-wrap)
(def s16 s16-not lognot s16-wrap)
(def s32 s32-not lognot s32-wrap)
(def s64 s64-not lognot s64-wrap)
|#
;;; Binary Operations

(macrolet ((def (type name op &optional (wrapper 'identity))
             `(progn
                (declaim (inline ,name))
                (defun ,name (a b)
                  (declare (type ,type a b))
                  (,wrapper (,op a b)))
                (define-fnrecord ,name (a b)
                  (:properties :foldable :movable)
                  (:specializer
                   (wrap-default (type-specifier-ntype ',type)))))))
  ;; u8
  (def u8 two-arg-u8-and logand)
  (def u8 two-arg-u8-or logior)
  (def u8 two-arg-u8-xor logxor)
  (def u8 two-arg-u8-max max)
  (def u8 two-arg-u8-min min)
  (def u8 two-arg-u8+ + u8-wrap)
  (def u8 two-arg-u8- - u8-wrap)
  (def u8 two-arg-u8=  =)
  (def u8 two-arg-u8/= /=)
  (def u8 two-arg-u8<  <)
  (def u8 two-arg-u8<= <=)
  (def u8 two-arg-u8>  >)
  (def u8 two-arg-u8>= >=)
  (def u8 u8-andc1 logandc1)
  ;; u16
  (def u16 two-arg-u16-and logand)
  (def u16 two-arg-u16-or logior)
  (def u16 two-arg-u16-xor logxor)
  (def u16 two-arg-u16-max max)
  (def u16 two-arg-u16-min min)
  (def u16 two-arg-u16+ + u16-wrap)
  (def u16 two-arg-u16- - u16-wrap)
  (def u16 two-arg-u16=  =)
  (def u16 two-arg-u16/= /=)
  (def u16 two-arg-u16<  <)
  (def u16 two-arg-u16<= <=)
  (def u16 two-arg-u16>  >)
  (def u16 two-arg-u16>= >=)
  (def u16 u16-andc1 logandc1)
  ;; u32
  (def u32 two-arg-u32-and logand)
  (def u32 two-arg-u32-or logior)
  (def u32 two-arg-u32-xor logxor)
  (def u32 two-arg-u32-max max)
  (def u32 two-arg-u32-min min)
  (def u32 two-arg-u32+ + u32-wrap)
  (def u32 two-arg-u32- - u32-wrap)
  (def u32 two-arg-u32=  = )
  (def u32 two-arg-u32/= /=)
  (def u32 two-arg-u32<  < )
  (def u32 two-arg-u32<= <=)
  (def u32 two-arg-u32>  > )
  (def u32 two-arg-u32>= >=)
  (def u32 u32-andc1 logandc1)
  ;; u64
  (def u64 two-arg-u64-and logand)
  (def u64 two-arg-u64-or logior)
  (def u64 two-arg-u64-xor logxor)
  (def u64 two-arg-u64-max max)
  (def u64 two-arg-u64-min min)
  (def u64 two-arg-u64+ + u64-wrap)
  (def u64 two-arg-u64- - u64-wrap)
  (def u64 two-arg-u64=  = )
  (def u64 two-arg-u64/= /=)
  (def u64 two-arg-u64<  < )
  (def u64 two-arg-u64<= <=)
  (def u64 two-arg-u64>  > )
  (def u64 two-arg-u64>= >=)
  (def u64 u64-andc1 logandc1)
  ;; s8
  (def s8 two-arg-s8-and logand)
  (def s8 two-arg-s8-or logior)
  (def s8 two-arg-s8-xor logxor)
  (def s8 two-arg-s8-max max)
  (def s8 two-arg-s8-min min)
  (def s8 two-arg-s8+ + s8-wrap)
  (def s8 two-arg-s8- - s8-wrap)
  (def s8 two-arg-s8=  = )
  (def s8 two-arg-s8/= /=)
  (def s8 two-arg-s8<  < )
  (def s8 two-arg-s8<= <=)
  (def s8 two-arg-s8>  > )
  (def s8 two-arg-s8>= >=)
  (def s8 s8-andc1 logandc1)
  ;; s16
  (def s16 two-arg-s16-and logand)
  (def s16 two-arg-s16-or logior)
  (def s16 two-arg-s16-xor logxor)
  (def s16 two-arg-s16-max max)
  (def s16 two-arg-s16-min min)
  (def s16 two-arg-s16+ + s16-wrap)
  (def s16 two-arg-s16- - s16-wrap)
  (def s16 two-arg-s16=  = )
  (def s16 two-arg-s16/= /=)
  (def s16 two-arg-s16<  < )
  (def s16 two-arg-s16<= <=)
  (def s16 two-arg-s16>  > )
  (def s16 two-arg-s16>= >=)
  (def s16 s16-andc1 logandc1)
  ;; s32
  (def s32 two-arg-s32-and logand)
  (def s32 two-arg-s32-or logior)
  (def s32 two-arg-s32-xor logxor)
  (def s32 two-arg-s32-max max)
  (def s32 two-arg-s32-min min)
  (def s32 two-arg-s32+ + s32-wrap)
  (def s32 two-arg-s32- - s32-wrap)
  (def s32 two-arg-s32=  = )
  (def s32 two-arg-s32/= /=)
  (def s32 two-arg-s32<  < )
  (def s32 two-arg-s32<= <=)
  (def s32 two-arg-s32>  > )
  (def s32 two-arg-s32>= >=)
  (def s32 s32-andc1 logandc1)
  ;; s64
  (def s64 two-arg-s64-and logand)
  (def s64 two-arg-s64-or logior)
  (def s64 two-arg-s64-xor logxor)
  (def s64 two-arg-s64-max max)
  (def s64 two-arg-s64-min min)
  (def s64 two-arg-s64+ + s64-wrap)
  (def s64 two-arg-s64- - s64-wrap)
  (def s64 two-arg-s64=  = )
  (def s64 two-arg-s64/= /=)
  (def s64 two-arg-s64<  < )
  (def s64 two-arg-s64<= <=)
  (def s64 two-arg-s64>  > )
  (def s64 two-arg-s64>= >=)
  (def s64 s64-andc1 logandc1))

#+(or)
(macrolet ((define-associative (name type body &optional identity-element)
             (let ((binary-operation (intern (concatenate 'string "TWO-ARG-" name) #.*PACKAGE*)))
               (if (not identity-element)
                   `(progn
                      (declaim (inline ,binary-operation))
                      (declaim (ftype (function (,type ,type) (values ,tr &optional)) ,binary-operation))
                      (defun ,binary-operation (a b) ,@body)
                      (defun ,name (arg &rest more-args)
                        (let ((result (,type arg)))
                          (declare (,type result))
                          (loop for arg in more-args
                                do (setf result (,binary-operation result (,type arg))))
                          result))
                      (define-compiler-macro ,name (&whole whole &rest args)
                        (let ((n (length args)))
                          (case n
                            (0 whole)
                            (1 `(,',type ,(first args)))
                            (otherwise
                             `(,',binary-operation
                               (,',name ,@(subseq args 0 (floor n 2)))
                               (,',name ,@(subseq args (floor n 2)))))))))
                   `(progn
                      (defun ,name (&rest args)
                        (if (null args)
                            (,type ,identity-element)
                            (let ((result (,type (first args))))
                              (declare (,type result))
                              (loop for arg in (rest args)
                                    do (setf result (,binary-operation result (,type arg))))
                              result)))
                      (define-compiler-macro ,name (&rest args)
                        (let ((n (length args)))
                          (case n
                            (0 `(,',type ,,identity-element))
                            (1 `(,',type ,(first args)))
                            (otherwise
                             `(,',binary-operation
                               (,',name ,@(subseq args 0 (floor n 2)))
                               (,',name ,@(subseq args (floor n 2)))))))))))))
  )
